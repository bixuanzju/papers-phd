\section{Formalization of the Surface language}
\label{sec:surface}

% \begin{itemize}
% \item Expand the core language with datatypes and pattern matching by encoding.
% \item Give translation rules.
% \item Encode GADTs and maybe other Haskell extensions? GADTs seems challenging, so perhaps some other examples would be datatypes like $Fix f$, and $Monad$ as a record. Could formalize records in Haskell style.
% \end{itemize}

In this section, we formally present the surface language \sufcc,
built on top of \name with features that are convenient for functional
programming. Thanks to the expressiveness of \name, all these features
can be elaborated into the core language without extending the
built-in language constructs of \name. In what follows, we first give
the syntax of the surface language, followed by the typing rules, then
we show the formal translation rules that translates a surface
language expression to an expression in \name. Finally we prove the
type safety of the translation.

\subsection{Syntax}

The full syntax of \sufcc is defined in
Figure~\ref{fig:surface:syntax}. Compared with \name, \sufcc has a new
syntax category: a program, consisting of a list of datatype
declarations, followed by an expression. For the purpose of
presentation, we sometimes adopt the following syntactic convention:
\[
\overline{\tau}^n \rightarrow \tau_r \equiv \tau_1 \rightarrow \dots \rightarrow \tau_n \rightarrow \tau_r
\]

\paragraph{Algebraic Datatypes}
An \emph{algebraic datatype} $D$ is introduced as a top-level
$\mathbf{data}$ declaration with its \emph{data constructors}. The type
of a data constructor $K$ takes the form:
\[
[[K : (<<u:k>>n) -> (<<x : A>>) -> D@<<u>>n]]
\]
The first $n$ quantified type variables $[[<<u>>]]$ appear in the same
order in the result type $[[D@<<u>>]]$.  Note that the use of the
dependent product in the data constructor arguments (i.e.,
$[[(<<x:A>>)]]$) makes it possible to let the types of some data
constructor arguments depend on other data constructor arguments.
%whereas in Haskell, this is not possible, because the function type
%($\rightarrow$) can be seen as an independent product type. 
The $\mathbf{case}$ expression is conventional, used to break up values
built with data constructors.  The patterns of a case expression are
flat (i.e., no nested patterns), and bind variables.
We also introduce a Haskell-like record syntax,
which are desugared to datatypes with accompanying selector functions.

{
\begin{figure}[t]
\footnotesize
\centering
\begin{spacing}{0.9}
\gram{\ottpgm\ottinterrule
\ottdecl\ottinterrule
\ottu\ottinterrule
\ottp\ottinterrule
\ottE\ottinterrule
\ottGs}
\[
    \begin{array}{l}
    \text{Syntactic Sugar} \\
    \ottsurfsugar \end{array}\]
\end{spacing}
\caption{Syntax of \sufcc}
\label{fig:surface:syntax}
\end{figure}
}

\begin{figure}[htpb]
\small
% \centering
% \renewcommand{\ottinterrule}{\\[1.0mm]}
% \begin{spacing}{1.3}
% \renewcommand{\ottdrule}[4][]{{\inferrule{#2 }{#3}\,\ottdrulename{#4}}}
% \renewenvironment{ottdefnblock}[3][]{\raggedright \framebox{\mbox{#2}} \quad #3 \\[0pt]}{}
% \renewcommand{\ottusedrule}[1]{$#1\quad$}
\ottdefnctxtrans{}\ottinterrule
\ottdefnpgmtrans{}\ottinterrule
\ottdefndecltrans{}
\[\hlmath{\ottdecltrans}\]\ottinterrule % defined in otthelper.mng.tex
\ottdefnpattrans{}\ottinterrule
% \setlength{\lineskip}{8pt}
\ottdefnexprtrans{}
% \end{spacing}
\caption{Type-directed translation rules of \sufcc}
\label{fig:source:translate}
\end{figure}

\paragraph{No Casts on The Surface}
A noticeable difference from \name is that, in \sufcc, we do not allow
\cast operations to appear in surface programs. However, the surface
language takes good advantage of the benefits of the core
language. The encoding of datatypes and case analysis uses casts and
type-level computation steps in a fundamental way: we need to use
casts to simulate \fold/\unfold, and we also need small type-level
computational steps to encode parametrised datatypes. Casts are mostly
intended to be generated by the compiler for \sufcc, not by the
programmers. An unfortunate consequence is that, this, for now, makes
the surface language less expressive (e.g., no explicit type-level
computation) than \name. One avenue for future work is to explore the
addition of good, surface level, mechanisms for doing type-level
computation built on top of casts.
%However, as we will point in
%Section~\ref{sec:discuss}, we plan to address this issue in the future.
%we will add new language constructs in
%\sufcc that help programmers perform type-level computation in a way
%like type classes or type families do for Haskell programmers.

\begin{comment}
\paragraph{Syntactic Sugar}
For the sake of programming, \sufcc employs some syntactic sugar shown
in Figure \ref{fig:surface:syntax}. A non-dependent function type can
be written as $[[A1 -> A2]]$. A dependent function type
$[[Pi x : A1 . A2]]$ is abbreviated as $[[(x : A1) -> A2]]$ for easier
reading. A standard $\mathbf{letrec}$ construct is used to build
recursive functions. We also introduce a Haskell-like record syntax,
which are desugared to datatypes with accompanying selector functions.
\end{comment}


\subsection{Typing Rules}
Figure~\ref{fig:source:translate} defines the type system of the
surface language. The gray parts can be ignored for the
moment. Several new typing judgments are introduced in the type
system. The use of different subscripts in the judgments is to be
distinct from the ones used in \name. Most rules are standard for
systems based on \coc, including the rules for the well-formedness of
contexts (\ruleref{TRenv\_Empty}, \ruleref{TRenv\_Var}), inferring the
types of variables (\ruleref{TR\_Var}), and dependent application
(\ruleref{TR\_App}).

% Two judgments $[[Gs |- pgm : A]]$ and
% $[[Gs |- decl : Gs']]$ type check a whole program, and datatype
% declarations, respectively.

Rule \ruleref{TRpgm\_Pgm} type checks a whole program. It first
type-checks the declarations, which in return gives a new typing
environment. Combined with the original environment, it then continues
to type check the final expression and return the result type. Rule
\ruleref{TRpgm\_Data} is used to type check datatype declarations. It
first ensures the well-formedness of the type of the type constructor
(of sort $\star$). Then it ensures that the types of data constructors
are valid.  Note that since our system adopts the $\star : \star$
axiom, this means we can express kind polymorphism in datatypes.

Rules \ruleref{TR\_Case} and \ruleref{TRpat\_Alt} handle the type
checking of case expressions. The conclusion of \ruleref{TS\_Case}
binds the scrutinee $[[E1]]$ and alternatives
$\overline{p \Rightarrow E_2}$ to the right types. The first premise
of \ruleref{TS\_Case} binds the actual type constructor arguments to
$[[<<U>>]]$. The second premise checks whether the types of the
alternatives, instantiated to the actual type constructor arguments
$[[<<U>>]]$ (via \ruleref{TRpat\_Alt}), are equal. Finally the third
premise checks the well-formedness of the result type.

%As can be seen, currently \sufcc does not support refinement on the
%final result of each data constructor, as in GADTs. However, our
%encoding method does support some form of GADTs, as is discussed in
%Section~\ref{Discussion}.

\subsection{Translation Overview}

We use a type-directed translation. The basic translation rules have the form:
\[
[[Gs  |- E : A ~> e]]
\]
The rule states that \name expression $[[e]]$ is the translation of the
surface expression $[[E]]$ of type $[[A]]$.  The gray parts in
Figure~\ref{fig:source:translate} define the translation
rules. 

Among others, rules \ruleref{TRdecl\_Data}, \ruleref{TRpat\_Alt} and
\ruleref{TR\_Case} are the essence of the translation. Rule
\ruleref{TR\_Case} translates case expressions into applications by
first translating the scrutinee $E_1$ to $e_1$, casting it down to the
right type. It is then applied to the result type of the body
expression and a list of \name expressions of the alternatives. Rule
\ruleref{TRpat\_Alt} translates each alternative into a lambda
abstraction, where each bound variable in the pattern corresponds to
bound variables in the lambda abstraction in the same order. The body
in the alternative is recursively translated and treated as the body
of the lambda abstraction. % Note that due to the rigidness of the
% translation, pattern matching must be exhaustive, and the order of
% patterns matters (the same order as in the datatype declaration).

As for the translation of datatypes, we choose to work with the Scott
encodings of datatypes~\cite{encoding:scott}. Scott encodings encode
case analysis, making it convenient to translate pattern
matching. Rule \ruleref{TRDecl\_Data} translates datatypes into \name
expressions. First of all, it results in an incomplete expression (as
can be seen by the incomplete $\mathsf{let}$ expressions). The result
expression is supposed to be prepended to the translation of the last
expression to form a complete \name expression, as specified by Rule
\ruleref{TRpgm\_Pgm}. Furthermore, each type constructor is translated
to a recursive type, of which the body is a type-level lambda
abstraction. What is interesting is that each recursive occurrence of
the datatype in the data constructor parameters is replaced with the
variable $[[X]]$. Note that for the moment, the result type variable
$[[bb]]$ is restricted to have kind $\star$. This could pose
difficulties when translating GADTs, which is an interesting topic for
future work. Each data constructor is translated to a lambda
abstraction. Notice how we use $[[castup]]$ in the lambda body to get
the right type.

The rest of the translation rules hold few surprises.

\subsection{Type Safety of the Translation}

Now that we have elaborated the translation, we can state the
type safety theorem of the translation.

\begin{theorem}[Type Safety of Expression Translation]
Given a surface language expression $[[E]]$ and context $[[Gs]]$, 
if $[[Gs |- E:A ~> e]]$, $[[Gs |- A:star ~> t]]$ and $[[|- Gs ~> G]]$, then
$[[G |- e:t]]$.
\end{theorem}

The proof is by induction on the derivation of $[[Gs |- E : A ~> e]]$.
Most of the rules are straightforward, following directly by
induction. The most heavy one is the rule \ruleref{TR\_Case}, where we
combine the information from rule \ruleref{TRpgm\_Data} and rule
\ruleref{TRpat\_Alt} with the operational semantics. The full proof of
type-safety appears in the full version of this paper.

%%% Local Variables:
%%% mode: latex
%%% TeX-master: "../main"
%%% End:
